<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\AccountType;
use App\Models\Destination;
use App\Models\Bus;
use App\Models\Route;
use App\Models\Account;
use App\Models\Schedule;
use App\Models\Booking;
use App\Models\Ticket;
use App\Models\Transaction;

class DatabaseSeeder extends Seeder
{
    public function run()
    {
        // 1. Static Lookup Tables
        $this->call([
            AccountTypeSeeder::class,
            DestinationSeeder::class,
            RouteSeeder::class,
        ]);

        // 2. Create Fleet
        // We create them, but we won't use the returned objects directly 
        // because their IDs are empty in PHP memory.
        Bus::factory(10)->create();
        // Fetch them back from DB so we have the IDs (BUS001, etc.)
        $buses = Bus::all(); 

        // 3. Fetch Routes (Seeded via RouteSeeder)
        $routes = Route::all();

        // 4. Create Users
        $custType = AccountType::where('name', 'Customer')->first();

        // Create Admins using Factory States
        Account::factory()->superAdmin()->create();
        Account::factory()->financialAdmin()->create();
        Account::factory()->schedulingAdmin()->create();
        Account::factory()->operationsAdmin()->create();

        // Create Manual Account (Rico)
        Account::factory()->rico()->create();
        Account::factory()->jojo()->create();
        Account::factory()->jason()->create();

        // Create Customers
        Account::factory(5)->create([
            'account_type_id' => $custType->id
        ]);
        // FETCH THEM BACK TO GET IDs (C-2025...)
        $customers = Account::where('account_type_id', $custType->id)->get();

        // Create Drivers
        $driverType = AccountType::where('name', 'Driver')->first();
        Account::factory(3)->create([
            'account_type_id' => $driverType->id,
            'first_name' => 'Driver', // Will append sequence by factory usually or random
        ]);
        $drivers = Account::where('account_type_id', $driverType->id)->get();

        // 5. Create Schedules (Trips)
        foreach(range(1, 50) as $i) {
            // Pick a random route from seeded routes
            $selectedRoute = $routes->random();

            Schedule::factory()->create([
                'route_id' => $selectedRoute->id,
                'bus_id' => $buses->random()->id,
                'driver_id' => $drivers->random()->id,
            ]);
        }
        
        // FETCH SCHEDULES BACK
        $schedules = Schedule::all();

        // 5b. Create Schedules for TODAY (for Driver Testing)
        // 5b. Create Schedules for TODAY (for Driver Testing)
        // We create them, but better to re-fetch them to guarantee we have the IDs (if generated by trigger)
        foreach(range(1, 3) as $i) {
             Schedule::factory()->create([
                'route_id' => $routes->random()->id,
                'bus_id' => $buses->random()->id,
                'driver_id' => $drivers->random()->id,
                'departure_time' => \Carbon\Carbon::now()->addHours(rand(2, 6)), // Today, few hours from now
                'arrival_time' => \Carbon\Carbon::now()->addHours(rand(8, 12)),
            ]);
        }
        
        // Refresh schedules to include today's content
        $schedules = Schedule::all();
        
        // Identify the "Today" schedules we just created for the simulation
        // The factory created ones for 'Today' are distinct from the loop of 50 which are +1 month usually (if factory defaults)
        // Actually, factory defaults are '+1 month'. Our explicit ones are 'now'.
        // So we can filter:
        $todaySchedules = $schedules->filter(function($s) {
            return \Carbon\Carbon::parse($s->departure_time)->isToday();
        });

        // 6. Generate Schedule Details & Simulate Bookings
        // Ensure "Today's" schedules are included in the details generation
        // Take 2 random existing ones + ALL of today's schedules
        $selectedSchedules = $schedules->where('departure_time', '>', now()->addDay())->random(2)->merge($todaySchedules);

        foreach($selectedSchedules as $schedule) {
            // "Just make 10 for only a few schedules" 
            // We will create exactly 10 Bookings/Tickets/Details for this schedule.
            // All of them will have a ticket_id (None null).
            $seatsToBook = 10;
            
            // Track booked seats to avoid collisions if we were randomizing, 
            // but here we can just iterate 1 to 10 linearly for simplicity 
            // and guaranteed non-null ticket_id.

            for ($i = 1; $i <= $seatsToBook; $i++) {
                $customer = $customers->random();
                
                // 1. Create Booking (1 Seat)
                // We create 1 booking per seat for simplicity to ensure 1:1 mapping easily
                $booking = Booking::create([
                    'account_id' => $customer->id,
                    'schedule_id' => $schedule->id,
                    'booking_date' => now(),
                    'travel_date' => $schedule->departure_time,
                    'total_amount' => $schedule->price_per_seat,
                    'status' => 'Confirmed'
                ]);

                // Refetch Booking ID
                $booking = Booking::where('account_id', $customer->id)
                    ->where('schedule_id', $schedule->id)
                    ->latest()
                    ->first();

                if (!$booking) continue;
                
                // Seat logic: A1, A2, B1, B2... (Assuming 2 chars per row or similar?)
                // Simple logic: Row + Col. Let's assume 4 cols per row.
                // i starts at 1.
                // Row 1: 1, 2, 3, 4 -> A1, A2, B1, B2 ? Or A1, B1, C1, D1?
                // Standard Bus: 
                // Col A, Col B --aisle-- Col C, Col D
                // Row 1: 1A, 1B, 1C, 1D?
                // User asked for "A1". Let's assume Rows are Numbers, Cols are Letters.
                // Or Rows are Letters (A-Z), Cols are Numbers? "A1" usually means Row A, Seat 1.
                
                $rowNum = ceil($i / 4); // 1, 1, 1, 1, 2...
                $colNum = ($i - 1) % 4; // 0, 1, 2, 3
                $colLetter = chr(65 + $colNum); // A, B, C, D
                $seatLabel = $colLetter . $rowNum; // A1, B1, C1, D1...

                // 2. Create Ticket
                Ticket::create([
                    'booking_id' => $booking->id,
                    'passenger_name' => $customer->first_name,
                    'seat_number' => $seatLabel,
                    'status' => 'Valid'
                ]);

                // Refetch Ticket ID
                $ticket = Ticket::where('booking_id', $booking->id)
                                ->where('seat_number', $seatLabel)
                                ->first();

                if ($ticket) {
                    // 3. Create Transaction
                    Transaction::create([
                        'account_id' => $customer->id,
                        'booking_id' => $booking->id,
                        'ticket_id' => null, 
                        'transaction_date' => now(),
                        'payment_method' => 'Credit Card',
                        'sub_total' => $schedule->price_per_seat,
                        'total_amount' => $schedule->price_per_seat,
                        'type' => 'Payment',
                        'status' => 'Success'
                    ]);

                    // 4. Create ScheduleDetail
                    // Strictly linked to the ticket, so ticket_id is NEVER null.
                    \App\Models\ScheduleDetail::create([
                        'schedule_id' => $schedule->id,
                        'sequence' => $i,
                        'ticket_id' => $ticket->id,
                        'seat_number' => $seatLabel, // Added
                        'attendance_status' => 'Pending',
                        'remarks' => null
                    ]);
                }
            }
        }

        // 7. Seed Expenses
        $this->call(ExpenseSeeder::class);
    }
}